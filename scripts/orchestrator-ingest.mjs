#!/usr/bin/env node
/**
 * Minimal ingest script for dry-run iterations.
 * Reads latest reports/*.json, opens/updates a GitHub Issue for each action_recommendation.
 * Uses GITHUB_TOKEN via environment (GitHub Actions).
 */
import fs from 'node:fs';
import path from 'node:path';
import { execSync } from 'node:child_process';

function log(msg, obj) {
  console.log('[ingest]', msg, obj ? JSON.stringify(obj) : '');
}

const repo = process.env.GITHUB_REPOSITORY; // owner/repo
const token = process.env.GITHUB_TOKEN;

if (!repo) {
  log('Missing GITHUB_REPOSITORY in env');
  process.exit(0);
}

if (!token) {
  log('Missing GITHUB_TOKEN in env');
  process.exit(0);
}

function readConfig() {
  const cfgPath = path.join(process.cwd(), 'orchestrator.yml');
  if (!fs.existsSync(cfgPath)) return null;
  return fs.readFileSync(cfgPath, 'utf8'); // keep raw for now
}

function findLatestReport() {
  const dir = path.join(process.cwd(), 'reports');
  if (!fs.existsSync(dir)) return null;
  const files = fs.readdirSync(dir).filter(f => f.endsWith('.json')).map(f => ({
    name: f,
    mtime: fs.statSync(path.join(dir, f)).mtimeMs
  }));
  if (!files.length) return null;
  files.sort((a, b) => b.mtime - a.mtime);
  return path.join(dir, files[0].name);
}

function openOrUpdateIssue(recommendation, iteration, report) {
  const title = `Dry Run Iteration ${iteration}: ${recommendation.summary}`;
  const issueLabel = 'dry-run';
  const autogenLabel = 'ai2/autogen';

  // Try to find existing issue by title (simple gh search)
  let existing = null;
  try {
    const out = execSync(`gh issue list --search "${title}" --json number,title,state,labels`);
    const parsed = JSON.parse(out.toString());
    existing = parsed.find(i => i.title === title && i.state === 'OPEN');
  } catch (e) {
    log('Issue search failed (non-critical)', { error: e.message });
  }

  const acceptanceYaml = [
    '```yaml',
    'acceptance:',
    `  tests_should_pass: ${JSON.stringify(recommendation.acceptance?.tests_should_pass || [])}`,
    `  forbidden_strings: ${JSON.stringify(recommendation.acceptance?.forbidden_strings || [])}`,
    '```'
  ].join('\n');

  const body = [
    `Iteration: ${iteration}`,
    `Summary: ${recommendation.summary}`,
    '',
    'Latest Report Metadata:',
    '```json',
    JSON.stringify(report.report_metadata || {}, null, 2),
    '```',
    '',
    'Acceptance Criteria:',
    acceptanceYaml,
    '',
    '_Generated by orchestrator-ingest.mjs_'
  ].join('\n');

  if (existing) {
    log('Updating existing issue', { number: existing.number });
    execSync(`gh issue edit ${existing.number} --body "${escapeShell(body)}"`);
    return;
  }

  log('Creating new issue', { title });
  execSync(`gh issue create --title "${escapeShell(title)}" --label "${issueLabel},${autogenLabel}" --body "${escapeShell(body)}"`);
}

function escapeShell(s) {
  return s.replace(/(["$`\\])/g, '\\$1');
}

function main() {
  const cfg = readConfig();
  if (cfg) log('Loaded orchestrator.yml');

  const reportPath = findLatestReport();
  if (!reportPath) {
    log('No report JSON found');
    return;
  }
  log('Using report', { path: reportPath });

  const raw = fs.readFileSync(reportPath, 'utf8');
  let report;
  try {
    report = JSON.parse(raw);
  } catch (e) {
    log('Failed to parse report JSON', { error: e.message });
    return;
  }

  const iteration = report.report_metadata?.iteration ?? 'unknown';
  const recs = report.action_recommendations || [];
  if (!recs.length) {
    log('No action recommendations; nothing to do');
    return;
  }

  for (const r of recs) {
    openOrUpdateIssue(r, iteration, report);
  }
}

main();