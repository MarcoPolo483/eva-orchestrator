import { Octokit } from "@octokit/rest";
import fs from "node:fs";
import path from "node:path";
import yaml from "js-yaml";
import pLimit from "p-limit";
import { ensureRepo, ensureTrackingIssue, pushDirectory, upsertLabel } from "./github.js";

type Agent = {
  name: string;
  id: string;
  repos: string[];
  responsibilities: string[];
};

type Registry = {
  org: string;
  defaultBranch: string;
  agents: Agent[];
};

function uniq<T>(arr: T[]): T[] {
  return Array.from(new Set(arr));
}

function readRegistry(): Registry {
  const raw = fs.readFileSync(path.resolve("agents/registry.yaml"), "utf8");
  return yaml.load(raw) as Registry;
}

async function main() {
  const token = process.env.GITHUB_TOKEN || process.env.GH_TOKEN;
  if (!token) {
    console.error("Missing GITHUB_TOKEN (or GH_TOKEN) env var. Create a PAT with repo+workflow scopes.");
    process.exit(1);
  }

  const dryRun = !!process.env.DRY_RUN;
  const registry = readRegistry();
  const owner = process.env.EVA_OWNER || registry.org;
  const defaultBranch = process.env.DEFAULT_BRANCH || registry.defaultBranch || "main";
  const octokit = new Octokit({ auth: token });

  const repoNames = uniq(registry.agents.flatMap(a => a.repos));
  console.log(`Owner: ${owner}`);
  console.log(`Repos to ensure: ${repoNames.length}`);
  console.log(`Dry run: ${dryRun ? "YES" : "NO"}`);

  // Ensure repos
  for (const name of repoNames) {
    if (dryRun) { console.log(`[DRY] would ensure repo ${owner}/${name}`); continue; }
    await ensureRepo(octokit, { owner, name, defaultBranch, private: true });
    console.log(`Ensured repo ${owner}/${name}`);
  }

  // Push templates
  const limit = pLimit(3);
  const tasks = repoNames.map(repo =>
    limit(async () => {
      const templateDir = path.resolve("templates", repo);
      if (fs.existsSync(templateDir)) {
        if (dryRun) { console.log(`[DRY] would push ${templateDir} -> ${owner}/${repo}`); return; }
        await pushDirectory(octokit, owner, repo, templateDir, "scaffold");
        console.log(`Pushed templates to ${owner}/${repo}`);
      } else {
        // push minimal README
        const content = `# ${repo}\n\nInitial scaffold for EVA 2.0 module.\n`;
        if (!dryRun) {
          await pushDirectoryFallback(octokit, owner, repo, content);
        }
        console.log(`Pushed minimal README to ${owner}/${repo}`);
      }

      // Labels and tracking issue
      const sequence = [
        "infra:ready","utils:ready","core:ready","auth:ready","agent:ready","openai:ready",
        "rag:ready","api:ready","mcp:ready","safety:ready","metering:ready","ops:ready",
        "ui:ready","i18n:ready","i11y:ready","seed:ready","enterprise:ready"
      ];
      if (!dryRun) {
        for (const l of sequence) await upsertLabel(octokit, owner, repo, l, "0E8A16", `Readiness milestone: ${l}`);
      }

      const agent = registry.agents.find(a => a.repos.includes(repo));
      if (agent && !dryRun) {
        const title = `Tracking: ${agent.name} bootstrapping`;
        const body = [
          `Owner Agent: ${agent.name} (${agent.id})`,
          "",
          "Responsibilities:",
          ...agent.responsibilities.map(r => `- [ ] ${r}`),
          "",
          "Readiness label to apply when complete:",
          `- ${agent.id}:ready`,
          "",
          "_Generated by EVA Orchestrator_"
        ].join("\n");
        await ensureTrackingIssue(octokit, owner, repo, title, body);
      }
    })
  );
  await Promise.all(tasks);

  console.log("All done.");
}

async function pushDirectoryFallback(octokit: Octokit, owner: string, repo: string, readme: string) {
  const { putFile } = await import("./github.js");
  await putFile(octokit, owner, repo, "README.md", readme, "chore: scaffold README");
}

main().catch(e => {
  console.error(e);
  process.exit(1);
});